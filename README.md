## Устные вопросы
1. Какой самый эффективный способ конкатенации строк?
```
Лучший вариант определится по результату бенчмарка
Из явных претендентов это strings.Builder
и конкатенация через оператор +
```

2. Что такое интерфейсы, как они применяются в Go?
```
Интерфейс - это способ определения того, какие методы
должен реализовывать какой-либо объект
```

3. Чем отличаются RWMutex от Mutex?
```
Во время блокировки Mutex - нельзя включать любые другие блолкировки
А когда в RWMutex мы блокируем RLock, то можно конкуретно вызывать 
другие RLock, пока не появится Lock
```

4. Чем отличаются буферизированные и не буферизированные каналы?
```
В буфиризированном канале у нас есть буфер, который, пока в нем есть место, исключает блокировку на запись
В небуферизированном этот буфер равен нулю, что чуть облегчает сам канал,
но любые операции на запись/чтение должны быть сразу пойманы на другой стороне канала
```

5. Какой размер у структуры struct{}{}?
```
0 байт
```

6. Есть ли в Go перегрузка методов или операторов?
```
Нет
```

7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281
```
Порядок обхода в типе map является рандомизированным
```

8. В чем разница make и new?
```
Make - возвращает инициализированный тип (map, slice, chan)
New - возвращает указатель на тип с нулевым значением
```

9. Сколько существует способов задать переменную типа slice или map?
```
a := []int{}
b := make([]int)
c := make([]int, 0)
d := make([]int, 0, 1) // только slice
```

10. Что выведет данная программа и почему?
```go
func update(p *int) {
	b := 2
	p = &b // обновляем переменную в локальном стэке
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p) // 1
	update(p)
	fmt.Println(*p) // 1, выводим тот же указатель на переменную a
}

Для получения ожидаемого поведения, надо изменить функцию update:
func update(p *int) {
    b := 2
    *p = b
}
```

11. Что выведет данная программа и почему?
```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
		// Не допускается копирование sync.WaitGroup
		// так как внутри находится счетчик
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
		// Затенение переменной n
		// Для исправления 
        n := 1
        n++
    }
	// Выход из стэка условия if, n остается равной 0
    fmt.Println(n) // 0
}
```

13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100 // меняем первый элемент слайса (поменяется в исходном слайсе)
  // пытаемся добавить пришедший элемент, но т.к. в массиве нет места
  // он создаст новый с х2 cap внутри слайса, эти изменения не увидит оригинальный слайс
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5} // инициируем слайс из 5-ти элементов
  someAction(a, 6) // вызываем экшен с цифрой 6
  fmt.Println(a)
}

```

14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"} // len 2 cap 2

  // func получает копию слайса
  func(slice []string) {
     slice = append(slice, "a") // len 3 cap 4, внутренний массив поменялся
     slice[0] = "b" // меняем новый внутренний массив
     slice[1] = "b" // меняем новый внутренний массив
     fmt.Print(slice) // b b a
  }(slice)
  // после выполнения функции этот слайс не задет, т.к. после первого append мы аллоцировали новый массив
  fmt.Print(slice) // a a
}

```