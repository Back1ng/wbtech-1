## Устные вопросы
1. Какой самый эффективный способ конкатенации строк?
```
Лучший вариант определится по результату бенчмарка
Из явных претендентов это strings.Builder
и конкатенация через оператор +
```

2. Что такое интерфейсы, как они применяются в Go?
```
Интерфейс - это способ определения того, какие методы
должен реализовывать какой-либо объект
```

3. Чем отличаются RWMutex от Mutex?
```
Во время блокировки Mutex - нельзя включать любые другие блолкировки
А когда в RWMutex мы блокируем RLock, то можно конкуретно вызывать 
другие RLock, пока не появится Lock
```

4. Чем отличаются буферизированные и не буферизированные каналы?
```
В буфиризированном канале у нас есть буфер, который, пока в нем есть место, исключает блокировку на запись
В небуферизированном этот буфер равен нулю, что чуть облегчает сам канал,
но любые операции на запись/чтение должны быть сразу пойманы на другой стороне канала
```

5. Какой размер у структуры struct{}{}?
```
0 байт
```

6. Есть ли в Go перегрузка методов или операторов?
```
Нет
```

7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281
```
Порядок обхода в типе map является рандомизированным
```

8. В чем разница make и new?
```
Make - возвращает инициализированный тип (map, slice, chan)
New - возвращает указатель на тип с нулевым значением
```

9. Сколько существует способов задать переменную типа slice или map?
```
a := []int{}
b := make([]int)
c := make([]int, 0)
d := make([]int, 0, 1) // только slice
```

10. Что выведет данная программа и почему?
```go
func update(p *int) {
	b := 2
	p = &b // обновляем переменную в локальном стэке
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p) // 1
	update(p)
	fmt.Println(*p) // 1, выводим тот же указатель на переменную a
}

Для получения ожидаемого поведения, надо изменить функцию update:
func update(p *int) {
    b := 2
    *p = b
}
```

11. Что выведет данная программа и почему?
```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
		// Не допускается копирование sync.WaitGroup
		// так как внутри находится счетчик
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```

12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
		// Затенение переменной n
		// Для исправления 
        n := 1
        n++
    }
	// Выход из стэка условия if, n остается равной 0
    fmt.Println(n)
}
```